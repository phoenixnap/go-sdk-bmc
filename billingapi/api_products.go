/*
Billing API

Automate your infrastructure billing with the Bare Metal Cloud Billing API. Reserve your server instances to ensure guaranteed resource availability for 12, 24, and 36 months. Retrieve your serverâ€™s rated usage for a given period and enable or disable auto-renewals.<br> <br> <span class='pnap-api-knowledge-base-link'> Knowledge base articles to help you can be found <a href='https://phoenixnap.com/kb/phoenixnap-bare-metal-cloud-billing-models' target='_blank'>here</a> </span><br> <br> <b>All URLs are relative to (https://api.phoenixnap.com/billing/v1/)</b>

API version: 0.1
Contact: support@phoenixnap.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package billingapi

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"reflect"
)

type ProductsApi interface {

	/*
		ProductAvailabilityGet List all Product availabilities.

		Retrieves the list of product availability details.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiProductAvailabilityGetRequest
	*/
	ProductAvailabilityGet(ctx context.Context) ApiProductAvailabilityGetRequest

	// ProductAvailabilityGetExecute executes the request
	//  @return []ProductAvailability
	ProductAvailabilityGetExecute(r ApiProductAvailabilityGetRequest) ([]ProductAvailability, *http.Response, error)

	/*
		ProductsGet List all Products.

		Retrieves all Products.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiProductsGetRequest
	*/
	ProductsGet(ctx context.Context) ApiProductsGetRequest

	// ProductsGetExecute executes the request
	//  @return []ProductsGet200ResponseInner
	ProductsGetExecute(r ApiProductsGetRequest) ([]ProductsGet200ResponseInner, *http.Response, error)
}

// ProductsApiService ProductsApi service
type ProductsApiService service

type ApiProductAvailabilityGetRequest struct {
	ctx                          context.Context
	ApiService                   ProductsApi
	productCategory              *[]string
	productCode                  *[]string
	showOnlyMinQuantityAvailable *bool
	location                     *[]LocationEnum
	solution                     *[]string
	minQuantity                  *float32
}

// Product category. Currently only SERVER category is supported.
func (r ApiProductAvailabilityGetRequest) ProductCategory(productCategory []string) ApiProductAvailabilityGetRequest {
	r.productCategory = &productCategory
	return r
}

func (r ApiProductAvailabilityGetRequest) ProductCode(productCode []string) ApiProductAvailabilityGetRequest {
	r.productCode = &productCode
	return r
}

// Show only locations where product with requested quantity is available or all locations where product is offered.
func (r ApiProductAvailabilityGetRequest) ShowOnlyMinQuantityAvailable(showOnlyMinQuantityAvailable bool) ApiProductAvailabilityGetRequest {
	r.showOnlyMinQuantityAvailable = &showOnlyMinQuantityAvailable
	return r
}

func (r ApiProductAvailabilityGetRequest) Location(location []LocationEnum) ApiProductAvailabilityGetRequest {
	r.location = &location
	return r
}

func (r ApiProductAvailabilityGetRequest) Solution(solution []string) ApiProductAvailabilityGetRequest {
	r.solution = &solution
	return r
}

// Minimal quantity of product needed. Minimum, maximum and default values might differ for different products. For servers, they are 1, 10 and 1 respectively.
func (r ApiProductAvailabilityGetRequest) MinQuantity(minQuantity float32) ApiProductAvailabilityGetRequest {
	r.minQuantity = &minQuantity
	return r
}

func (r ApiProductAvailabilityGetRequest) Execute() ([]ProductAvailability, *http.Response, error) {
	return r.ApiService.ProductAvailabilityGetExecute(r)
}

/*
ProductAvailabilityGet List all Product availabilities.

Retrieves the list of product availability details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductAvailabilityGetRequest
*/
func (a *ProductsApiService) ProductAvailabilityGet(ctx context.Context) ApiProductAvailabilityGetRequest {
	return ApiProductAvailabilityGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ProductAvailability
func (a *ProductsApiService) ProductAvailabilityGetExecute(r ApiProductAvailabilityGetRequest) ([]ProductAvailability, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProductAvailability
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ProductAvailabilityGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/product-availability"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.productCategory != nil {
		t := *r.productCategory
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("productCategory", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("productCategory", parameterToString(t, "multi"))
		}
	}
	if r.productCode != nil {
		t := *r.productCode
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("productCode", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("productCode", parameterToString(t, "multi"))
		}
	}
	if r.showOnlyMinQuantityAvailable != nil {
		localVarQueryParams.Add("showOnlyMinQuantityAvailable", parameterToString(*r.showOnlyMinQuantityAvailable, ""))
	}
	if r.location != nil {
		t := *r.location
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("location", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("location", parameterToString(t, "multi"))
		}
	}
	if r.solution != nil {
		t := *r.solution
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("solution", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("solution", parameterToString(t, "multi"))
		}
	}
	if r.minQuantity != nil {
		localVarQueryParams.Add("minQuantity", parameterToString(*r.minQuantity, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	localVarHeaderParams["X-Powered-By"] = "PNAP-go-sdk-bmc/" + SdkVersion
	localVarHeaderParams["User-Agent"] = "PNAP-go-sdk-bmc/" + SdkVersion

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiProductsGetRequest struct {
	ctx             context.Context
	ApiService      ProductsApi
	productCode     *string
	productCategory *string
	skuCode         *string
	location        *string
}

func (r ApiProductsGetRequest) ProductCode(productCode string) ApiProductsGetRequest {
	r.productCode = &productCode
	return r
}

func (r ApiProductsGetRequest) ProductCategory(productCategory string) ApiProductsGetRequest {
	r.productCategory = &productCategory
	return r
}

func (r ApiProductsGetRequest) SkuCode(skuCode string) ApiProductsGetRequest {
	r.skuCode = &skuCode
	return r
}

func (r ApiProductsGetRequest) Location(location string) ApiProductsGetRequest {
	r.location = &location
	return r
}

func (r ApiProductsGetRequest) Execute() ([]ProductsGet200ResponseInner, *http.Response, error) {
	return r.ApiService.ProductsGetExecute(r)
}

/*
ProductsGet List all Products.

Retrieves all Products.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiProductsGetRequest
*/
func (a *ProductsApiService) ProductsGet(ctx context.Context) ApiProductsGetRequest {
	return ApiProductsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []ProductsGet200ResponseInner
func (a *ProductsApiService) ProductsGetExecute(r ApiProductsGetRequest) ([]ProductsGet200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ProductsGet200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductsApiService.ProductsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.productCode != nil {
		localVarQueryParams.Add("productCode", parameterToString(*r.productCode, ""))
	}
	if r.productCategory != nil {
		localVarQueryParams.Add("productCategory", parameterToString(*r.productCategory, ""))
	}
	if r.skuCode != nil {
		localVarQueryParams.Add("skuCode", parameterToString(*r.skuCode, ""))
	}
	if r.location != nil {
		localVarQueryParams.Add("location", parameterToString(*r.location, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	localVarHeaderParams["X-Powered-By"] = "PNAP-go-sdk-bmc/" + SdkVersion
	localVarHeaderParams["User-Agent"] = "PNAP-go-sdk-bmc/" + SdkVersion

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
