/*
Networks API

Create, list, edit and delete public/private networks with the Network API. Use public networks to place multiple  servers on the same network or VLAN. Assign new servers with IP addresses from the same CIDR range. Use private  networks to avoid unnecessary egress data charges. Model your networks according to your business needs.<br> <br> <span class='pnap-api-knowledge-base-link'> Helpful knowledge base articles are available for  <a href='https://phoenixnap.com/kb/bmc-server-management-via-api#multi-private-backend-network-api' target='_blank'>multi-private backend networks</a>,  <a href='https://phoenixnap.com/kb/bmc-server-management-via-api#ftoc-heading-15' target='_blank'>public networks</a> and <a href='https://phoenixnap.com/kb/border-gateway-protocol-bmc' target='_blank'>border gateway protocol peer groups</a>. </span><br> <br> <b>All URLs are relative to (https://api.phoenixnap.com/networks/v1/)</b>

API version: 1.0
Contact: support@phoenixnap.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package networkapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type BGPPeerGroupsAPI interface {

	/*
		BgpPeerGroupsGet List BGP Peer Groups.

		List all BGP Peer Groups owned by account.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiBgpPeerGroupsGetRequest
	*/
	BgpPeerGroupsGet(ctx context.Context) ApiBgpPeerGroupsGetRequest

	// BgpPeerGroupsGetExecute executes the request
	//  @return []BgpPeerGroup
	BgpPeerGroupsGetExecute(r ApiBgpPeerGroupsGetRequest) ([]BgpPeerGroup, *http.Response, error)

	/*
		BgpPeerGroupsPeerGroupIdDelete Delete a BGP Peer Group.

		Deletes BGP Peer Group by ID.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param bgpPeerGroupId The BGP peer group ID.
		@return ApiBgpPeerGroupsPeerGroupIdDeleteRequest
	*/
	BgpPeerGroupsPeerGroupIdDelete(ctx context.Context, bgpPeerGroupId string) ApiBgpPeerGroupsPeerGroupIdDeleteRequest

	// BgpPeerGroupsPeerGroupIdDeleteExecute executes the request
	//  @return BgpPeerGroup
	BgpPeerGroupsPeerGroupIdDeleteExecute(r ApiBgpPeerGroupsPeerGroupIdDeleteRequest) (*BgpPeerGroup, *http.Response, error)

	/*
		BgpPeerGroupsPeerGroupIdGet Get a BGP Peer Group.

		Retrieves BGP Peer Group by ID.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param bgpPeerGroupId The BGP peer group ID.
		@return ApiBgpPeerGroupsPeerGroupIdGetRequest
	*/
	BgpPeerGroupsPeerGroupIdGet(ctx context.Context, bgpPeerGroupId string) ApiBgpPeerGroupsPeerGroupIdGetRequest

	// BgpPeerGroupsPeerGroupIdGetExecute executes the request
	//  @return BgpPeerGroup
	BgpPeerGroupsPeerGroupIdGetExecute(r ApiBgpPeerGroupsPeerGroupIdGetRequest) (*BgpPeerGroup, *http.Response, error)

	/*
		BgpPeerGroupsPeerGroupIdPatch Modify a BGP Peer Group.

		Modifies BGP Peer Group by ID.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param bgpPeerGroupId The BGP peer group ID.
		@return ApiBgpPeerGroupsPeerGroupIdPatchRequest
	*/
	BgpPeerGroupsPeerGroupIdPatch(ctx context.Context, bgpPeerGroupId string) ApiBgpPeerGroupsPeerGroupIdPatchRequest

	// BgpPeerGroupsPeerGroupIdPatchExecute executes the request
	//  @return BgpPeerGroup
	BgpPeerGroupsPeerGroupIdPatchExecute(r ApiBgpPeerGroupsPeerGroupIdPatchRequest) (*BgpPeerGroup, *http.Response, error)

	/*
		BgpPeerGroupsPost Create a BGP Peer Group.

		Create a BGP Peer Group.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiBgpPeerGroupsPostRequest
	*/
	BgpPeerGroupsPost(ctx context.Context) ApiBgpPeerGroupsPostRequest

	// BgpPeerGroupsPostExecute executes the request
	//  @return BgpPeerGroup
	BgpPeerGroupsPostExecute(r ApiBgpPeerGroupsPostRequest) (*BgpPeerGroup, *http.Response, error)
}

// BGPPeerGroupsAPIService BGPPeerGroupsAPI service
type BGPPeerGroupsAPIService service

type ApiBgpPeerGroupsGetRequest struct {
	ctx        context.Context
	ApiService BGPPeerGroupsAPI
	location   *string
}

// If present will filter the result by the given location of the BGP Peer Group.
func (r ApiBgpPeerGroupsGetRequest) Location(location string) ApiBgpPeerGroupsGetRequest {
	r.location = &location
	return r
}

func (r ApiBgpPeerGroupsGetRequest) Execute() ([]BgpPeerGroup, *http.Response, error) {
	return r.ApiService.BgpPeerGroupsGetExecute(r)
}

/*
BgpPeerGroupsGet List BGP Peer Groups.

List all BGP Peer Groups owned by account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBgpPeerGroupsGetRequest
*/
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsGet(ctx context.Context) ApiBgpPeerGroupsGetRequest {
	return ApiBgpPeerGroupsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []BgpPeerGroup
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsGetExecute(r ApiBgpPeerGroupsGetRequest) ([]BgpPeerGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []BgpPeerGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BGPPeerGroupsAPIService.BgpPeerGroupsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-peer-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBgpPeerGroupsPeerGroupIdDeleteRequest struct {
	ctx            context.Context
	ApiService     BGPPeerGroupsAPI
	bgpPeerGroupId string
}

func (r ApiBgpPeerGroupsPeerGroupIdDeleteRequest) Execute() (*BgpPeerGroup, *http.Response, error) {
	return r.ApiService.BgpPeerGroupsPeerGroupIdDeleteExecute(r)
}

/*
BgpPeerGroupsPeerGroupIdDelete Delete a BGP Peer Group.

Deletes BGP Peer Group by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpPeerGroupId The BGP peer group ID.
 @return ApiBgpPeerGroupsPeerGroupIdDeleteRequest
*/
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPeerGroupIdDelete(ctx context.Context, bgpPeerGroupId string) ApiBgpPeerGroupsPeerGroupIdDeleteRequest {
	return ApiBgpPeerGroupsPeerGroupIdDeleteRequest{
		ApiService:     a,
		ctx:            ctx,
		bgpPeerGroupId: bgpPeerGroupId,
	}
}

// Execute executes the request
//  @return BgpPeerGroup
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPeerGroupIdDeleteExecute(r ApiBgpPeerGroupsPeerGroupIdDeleteRequest) (*BgpPeerGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BgpPeerGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BGPPeerGroupsAPIService.BgpPeerGroupsPeerGroupIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-peer-groups/{bgpPeerGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpPeerGroupId"+"}", url.PathEscape(parameterValueToString(r.bgpPeerGroupId, "bgpPeerGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBgpPeerGroupsPeerGroupIdGetRequest struct {
	ctx            context.Context
	ApiService     BGPPeerGroupsAPI
	bgpPeerGroupId string
}

func (r ApiBgpPeerGroupsPeerGroupIdGetRequest) Execute() (*BgpPeerGroup, *http.Response, error) {
	return r.ApiService.BgpPeerGroupsPeerGroupIdGetExecute(r)
}

/*
BgpPeerGroupsPeerGroupIdGet Get a BGP Peer Group.

Retrieves BGP Peer Group by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpPeerGroupId The BGP peer group ID.
 @return ApiBgpPeerGroupsPeerGroupIdGetRequest
*/
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPeerGroupIdGet(ctx context.Context, bgpPeerGroupId string) ApiBgpPeerGroupsPeerGroupIdGetRequest {
	return ApiBgpPeerGroupsPeerGroupIdGetRequest{
		ApiService:     a,
		ctx:            ctx,
		bgpPeerGroupId: bgpPeerGroupId,
	}
}

// Execute executes the request
//  @return BgpPeerGroup
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPeerGroupIdGetExecute(r ApiBgpPeerGroupsPeerGroupIdGetRequest) (*BgpPeerGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BgpPeerGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BGPPeerGroupsAPIService.BgpPeerGroupsPeerGroupIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-peer-groups/{bgpPeerGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpPeerGroupId"+"}", url.PathEscape(parameterValueToString(r.bgpPeerGroupId, "bgpPeerGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBgpPeerGroupsPeerGroupIdPatchRequest struct {
	ctx               context.Context
	ApiService        BGPPeerGroupsAPI
	bgpPeerGroupId    string
	bgpPeerGroupPatch *BgpPeerGroupPatch
}

func (r ApiBgpPeerGroupsPeerGroupIdPatchRequest) BgpPeerGroupPatch(bgpPeerGroupPatch BgpPeerGroupPatch) ApiBgpPeerGroupsPeerGroupIdPatchRequest {
	r.bgpPeerGroupPatch = &bgpPeerGroupPatch
	return r
}

func (r ApiBgpPeerGroupsPeerGroupIdPatchRequest) Execute() (*BgpPeerGroup, *http.Response, error) {
	return r.ApiService.BgpPeerGroupsPeerGroupIdPatchExecute(r)
}

/*
BgpPeerGroupsPeerGroupIdPatch Modify a BGP Peer Group.

Modifies BGP Peer Group by ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpPeerGroupId The BGP peer group ID.
 @return ApiBgpPeerGroupsPeerGroupIdPatchRequest
*/
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPeerGroupIdPatch(ctx context.Context, bgpPeerGroupId string) ApiBgpPeerGroupsPeerGroupIdPatchRequest {
	return ApiBgpPeerGroupsPeerGroupIdPatchRequest{
		ApiService:     a,
		ctx:            ctx,
		bgpPeerGroupId: bgpPeerGroupId,
	}
}

// Execute executes the request
//  @return BgpPeerGroup
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPeerGroupIdPatchExecute(r ApiBgpPeerGroupsPeerGroupIdPatchRequest) (*BgpPeerGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPatch
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BgpPeerGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BGPPeerGroupsAPIService.BgpPeerGroupsPeerGroupIdPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-peer-groups/{bgpPeerGroupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpPeerGroupId"+"}", url.PathEscape(parameterValueToString(r.bgpPeerGroupId, "bgpPeerGroupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bgpPeerGroupPatch == nil {
		return localVarReturnValue, nil, reportError("bgpPeerGroupPatch is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bgpPeerGroupPatch
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBgpPeerGroupsPostRequest struct {
	ctx                context.Context
	ApiService         BGPPeerGroupsAPI
	bgpPeerGroupCreate *BgpPeerGroupCreate
}

func (r ApiBgpPeerGroupsPostRequest) BgpPeerGroupCreate(bgpPeerGroupCreate BgpPeerGroupCreate) ApiBgpPeerGroupsPostRequest {
	r.bgpPeerGroupCreate = &bgpPeerGroupCreate
	return r
}

func (r ApiBgpPeerGroupsPostRequest) Execute() (*BgpPeerGroup, *http.Response, error) {
	return r.ApiService.BgpPeerGroupsPostExecute(r)
}

/*
BgpPeerGroupsPost Create a BGP Peer Group.

Create a BGP Peer Group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBgpPeerGroupsPostRequest
*/
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPost(ctx context.Context) ApiBgpPeerGroupsPostRequest {
	return ApiBgpPeerGroupsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BgpPeerGroup
func (a *BGPPeerGroupsAPIService) BgpPeerGroupsPostExecute(r ApiBgpPeerGroupsPostRequest) (*BgpPeerGroup, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BgpPeerGroup
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BGPPeerGroupsAPIService.BgpPeerGroupsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-peer-groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bgpPeerGroupCreate == nil {
		return localVarReturnValue, nil, reportError("bgpPeerGroupCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bgpPeerGroupCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
